{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@floating-ui/core')) : typeof define === 'function' && define.amd ? define(['exports', '@floating-ui/core'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.FloatingUIDOM = {}, global.FloatingUICore));\n})(this, function (exports, core) {\n  'use strict';\n\n  function getWindow(node) {\n    var _node$ownerDocument;\n    return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n  }\n  function getComputedStyle$1(element) {\n    return getWindow(element).getComputedStyle(element);\n  }\n  function isNode(value) {\n    return value instanceof getWindow(value).Node;\n  }\n  function getNodeName(node) {\n    if (isNode(node)) {\n      return (node.nodeName || '').toLowerCase();\n    }\n    // Mocked nodes in testing environments may not be instances of Node. By\n    // returning `#document` an infinite loop won't occur.\n    // https://github.com/floating-ui/floating-ui/issues/2317\n    return '#document';\n  }\n  function isHTMLElement(value) {\n    return value instanceof getWindow(value).HTMLElement;\n  }\n  function isElement(value) {\n    return value instanceof getWindow(value).Element;\n  }\n  function isShadowRoot(node) {\n    // Browsers without `ShadowRoot` support.\n    if (typeof ShadowRoot === 'undefined') {\n      return false;\n    }\n    return node instanceof getWindow(node).ShadowRoot || node instanceof ShadowRoot;\n  }\n  function isOverflowElement(element) {\n    const {\n      overflow,\n      overflowX,\n      overflowY,\n      display\n    } = getComputedStyle$1(element);\n    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n  }\n  function isTableElement(element) {\n    return ['table', 'td', 'th'].includes(getNodeName(element));\n  }\n  function isContainingBlock(element) {\n    const safari = isSafari();\n    const css = getComputedStyle$1(element);\n\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    return css.transform !== 'none' || css.perspective !== 'none' || !safari && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !safari && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n  }\n  function isSafari() {\n    if (typeof CSS === 'undefined' || !CSS.supports) return false;\n    return CSS.supports('-webkit-backdrop-filter', 'none');\n  }\n  function isLastTraversableNode(node) {\n    return ['html', 'body', '#document'].includes(getNodeName(node));\n  }\n  const min = Math.min;\n  const max = Math.max;\n  const round = Math.round;\n  const floor = Math.floor;\n  const createEmptyCoords = v => ({\n    x: v,\n    y: v\n  });\n  function getCssDimensions(element) {\n    const css = getComputedStyle$1(element);\n    // In testing environments, the `width` and `height` properties are empty\n    // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n    let width = parseFloat(css.width) || 0;\n    let height = parseFloat(css.height) || 0;\n    const hasOffset = isHTMLElement(element);\n    const offsetWidth = hasOffset ? element.offsetWidth : width;\n    const offsetHeight = hasOffset ? element.offsetHeight : height;\n    const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n    if (shouldFallback) {\n      width = offsetWidth;\n      height = offsetHeight;\n    }\n    return {\n      width,\n      height,\n      $: shouldFallback\n    };\n  }\n  function unwrapElement(element) {\n    return !isElement(element) ? element.contextElement : element;\n  }\n  function getScale(element) {\n    const domElement = unwrapElement(element);\n    if (!isHTMLElement(domElement)) {\n      return createEmptyCoords(1);\n    }\n    const rect = domElement.getBoundingClientRect();\n    const {\n      width,\n      height,\n      $\n    } = getCssDimensions(domElement);\n    let x = ($ ? round(rect.width) : rect.width) / width;\n    let y = ($ ? round(rect.height) : rect.height) / height;\n\n    // 0, NaN, or Infinity should always fallback to 1.\n\n    if (!x || !Number.isFinite(x)) {\n      x = 1;\n    }\n    if (!y || !Number.isFinite(y)) {\n      y = 1;\n    }\n    return {\n      x,\n      y\n    };\n  }\n  const noOffsets = /*#__PURE__*/createEmptyCoords(0);\n  function getVisualOffsets(element, isFixed, floatingOffsetParent) {\n    var _win$visualViewport, _win$visualViewport2;\n    if (isFixed === void 0) {\n      isFixed = true;\n    }\n    if (!isSafari()) {\n      return noOffsets;\n    }\n    const win = element ? getWindow(element) : window;\n    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== win) {\n      return noOffsets;\n    }\n    return {\n      x: ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0,\n      y: ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0\n    };\n  }\n  function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n    if (includeScale === void 0) {\n      includeScale = false;\n    }\n    if (isFixedStrategy === void 0) {\n      isFixedStrategy = false;\n    }\n    const clientRect = element.getBoundingClientRect();\n    const domElement = unwrapElement(element);\n    let scale = createEmptyCoords(1);\n    if (includeScale) {\n      if (offsetParent) {\n        if (isElement(offsetParent)) {\n          scale = getScale(offsetParent);\n        }\n      } else {\n        scale = getScale(element);\n      }\n    }\n    const visualOffsets = getVisualOffsets(domElement, isFixedStrategy, offsetParent);\n    let x = (clientRect.left + visualOffsets.x) / scale.x;\n    let y = (clientRect.top + visualOffsets.y) / scale.y;\n    let width = clientRect.width / scale.x;\n    let height = clientRect.height / scale.y;\n    if (domElement) {\n      const win = getWindow(domElement);\n      const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n      let currentIFrame = win.frameElement;\n      while (currentIFrame && offsetParent && offsetWin !== win) {\n        const iframeScale = getScale(currentIFrame);\n        const iframeRect = currentIFrame.getBoundingClientRect();\n        const css = getComputedStyle(currentIFrame);\n        const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n        const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n        x *= iframeScale.x;\n        y *= iframeScale.y;\n        width *= iframeScale.x;\n        height *= iframeScale.y;\n        x += left;\n        y += top;\n        currentIFrame = getWindow(currentIFrame).frameElement;\n      }\n    }\n    return core.rectToClientRect({\n      width,\n      height,\n      x,\n      y\n    });\n  }\n  function getDocumentElement(node) {\n    return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n  }\n  function getNodeScroll(element) {\n    if (isElement(element)) {\n      return {\n        scrollLeft: element.scrollLeft,\n        scrollTop: element.scrollTop\n      };\n    }\n    return {\n      scrollLeft: element.pageXOffset,\n      scrollTop: element.pageYOffset\n    };\n  }\n  function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n    let {\n      rect,\n      offsetParent,\n      strategy\n    } = _ref;\n    const isOffsetParentAnElement = isHTMLElement(offsetParent);\n    const documentElement = getDocumentElement(offsetParent);\n    if (offsetParent === documentElement) {\n      return rect;\n    }\n    let scroll = {\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    let scale = createEmptyCoords(1);\n    const offsets = createEmptyCoords(0);\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n      if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n        scroll = getNodeScroll(offsetParent);\n      }\n      if (isHTMLElement(offsetParent)) {\n        const offsetRect = getBoundingClientRect(offsetParent);\n        scale = getScale(offsetParent);\n        offsets.x = offsetRect.x + offsetParent.clientLeft;\n        offsets.y = offsetRect.y + offsetParent.clientTop;\n      }\n    }\n    return {\n      width: rect.width * scale.x,\n      height: rect.height * scale.y,\n      x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n      y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n    };\n  }\n  function getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n  }\n\n  // Gets the entire size of the scrollable document area, even extending outside\n  // of the `<html>` and `<body>` rect bounds if horizontally scrollable.\n  function getDocumentRect(element) {\n    const html = getDocumentElement(element);\n    const scroll = getNodeScroll(element);\n    const body = element.ownerDocument.body;\n    const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n    const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n    let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n    const y = -scroll.scrollTop;\n    if (getComputedStyle$1(body).direction === 'rtl') {\n      x += max(html.clientWidth, body.clientWidth) - width;\n    }\n    return {\n      width,\n      height,\n      x,\n      y\n    };\n  }\n  function getParentNode(node) {\n    if (getNodeName(node) === 'html') {\n      return node;\n    }\n    const result =\n    // Step into the shadow DOM of the parent of a slotted node.\n    node.assignedSlot ||\n    // DOM Element detected.\n    node.parentNode ||\n    // ShadowRoot detected.\n    isShadowRoot(node) && node.host ||\n    // Fallback.\n    getDocumentElement(node);\n    return isShadowRoot(result) ? result.host : result;\n  }\n  function getNearestOverflowAncestor(node) {\n    const parentNode = getParentNode(node);\n    if (isLastTraversableNode(parentNode)) {\n      return node.ownerDocument ? node.ownerDocument.body : node.body;\n    }\n    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n      return parentNode;\n    }\n    return getNearestOverflowAncestor(parentNode);\n  }\n  function getOverflowAncestors(node, list) {\n    var _node$ownerDocument;\n    if (list === void 0) {\n      list = [];\n    }\n    const scrollableAncestor = getNearestOverflowAncestor(node);\n    const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n    const win = getWindow(scrollableAncestor);\n    if (isBody) {\n      return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);\n    }\n    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));\n  }\n  function getViewportRect(element, strategy) {\n    const win = getWindow(element);\n    const html = getDocumentElement(element);\n    const visualViewport = win.visualViewport;\n    let width = html.clientWidth;\n    let height = html.clientHeight;\n    let x = 0;\n    let y = 0;\n    if (visualViewport) {\n      width = visualViewport.width;\n      height = visualViewport.height;\n      const visualViewportBased = isSafari();\n      if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n        x = visualViewport.offsetLeft;\n        y = visualViewport.offsetTop;\n      }\n    }\n    return {\n      width,\n      height,\n      x,\n      y\n    };\n  }\n\n  // Returns the inner client rect, subtracting scrollbars if present.\n  function getInnerBoundingClientRect(element, strategy) {\n    const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n    const top = clientRect.top + element.clientTop;\n    const left = clientRect.left + element.clientLeft;\n    const scale = isHTMLElement(element) ? getScale(element) : createEmptyCoords(1);\n    const width = element.clientWidth * scale.x;\n    const height = element.clientHeight * scale.y;\n    const x = left * scale.x;\n    const y = top * scale.y;\n    return {\n      width,\n      height,\n      x,\n      y\n    };\n  }\n  function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n    let rect;\n    if (clippingAncestor === 'viewport') {\n      rect = getViewportRect(element, strategy);\n    } else if (clippingAncestor === 'document') {\n      rect = getDocumentRect(getDocumentElement(element));\n    } else if (isElement(clippingAncestor)) {\n      rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n    } else {\n      const visualOffsets = getVisualOffsets(element);\n      rect = {\n        ...clippingAncestor,\n        x: clippingAncestor.x - visualOffsets.x,\n        y: clippingAncestor.y - visualOffsets.y\n      };\n    }\n    return core.rectToClientRect(rect);\n  }\n  function hasFixedPositionAncestor(element, stopNode) {\n    const parentNode = getParentNode(element);\n    if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n      return false;\n    }\n    return getComputedStyle$1(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n  }\n\n  // A \"clipping ancestor\" is an `overflow` element with the characteristic of\n  // clipping (or hiding) child elements. This returns all clipping ancestors\n  // of the given element up the tree.\n  function getClippingElementAncestors(element, cache) {\n    const cachedResult = cache.get(element);\n    if (cachedResult) {\n      return cachedResult;\n    }\n    let result = getOverflowAncestors(element).filter(el => isElement(el) && getNodeName(el) !== 'body');\n    let currentContainingBlockComputedStyle = null;\n    const elementIsFixed = getComputedStyle$1(element).position === 'fixed';\n    let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n      const computedStyle = getComputedStyle$1(currentNode);\n      const currentNodeIsContaining = isContainingBlock(currentNode);\n      if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n        currentContainingBlockComputedStyle = null;\n      }\n      const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n      if (shouldDropCurrentNode) {\n        // Drop non-containing blocks.\n        result = result.filter(ancestor => ancestor !== currentNode);\n      } else {\n        // Record last containing block for next iteration.\n        currentContainingBlockComputedStyle = computedStyle;\n      }\n      currentNode = getParentNode(currentNode);\n    }\n    cache.set(element, result);\n    return result;\n  }\n\n  // Gets the maximum area that the element is visible in due to any number of\n  // clipping ancestors.\n  function getClippingRect(_ref) {\n    let {\n      element,\n      boundary,\n      rootBoundary,\n      strategy\n    } = _ref;\n    const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n    const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n    const firstClippingAncestor = clippingAncestors[0];\n    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n      const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n      accRect.top = max(rect.top, accRect.top);\n      accRect.right = min(rect.right, accRect.right);\n      accRect.bottom = min(rect.bottom, accRect.bottom);\n      accRect.left = max(rect.left, accRect.left);\n      return accRect;\n    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n    return {\n      width: clippingRect.right - clippingRect.left,\n      height: clippingRect.bottom - clippingRect.top,\n      x: clippingRect.left,\n      y: clippingRect.top\n    };\n  }\n  function getDimensions(element) {\n    return getCssDimensions(element);\n  }\n  function getTrueOffsetParent(element, polyfill) {\n    if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {\n      return null;\n    }\n    if (polyfill) {\n      return polyfill(element);\n    }\n    return element.offsetParent;\n  }\n  function getContainingBlock(element) {\n    let currentNode = getParentNode(element);\n    while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n      if (isContainingBlock(currentNode)) {\n        return currentNode;\n      } else {\n        currentNode = getParentNode(currentNode);\n      }\n    }\n    return null;\n  }\n\n  // Gets the closest ancestor positioned element. Handles some edge cases,\n  // such as table ancestors and cross browser bugs.\n  function getOffsetParent(element, polyfill) {\n    const window = getWindow(element);\n    if (!isHTMLElement(element)) {\n      return window;\n    }\n    let offsetParent = getTrueOffsetParent(element, polyfill);\n    while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {\n      offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n    }\n    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n      return window;\n    }\n    return offsetParent || getContainingBlock(element) || window;\n  }\n  function getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n    const isOffsetParentAnElement = isHTMLElement(offsetParent);\n    const documentElement = getDocumentElement(offsetParent);\n    const isFixed = strategy === 'fixed';\n    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n    let scroll = {\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    const offsets = createEmptyCoords(0);\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n      if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n        scroll = getNodeScroll(offsetParent);\n      }\n      if (isHTMLElement(offsetParent)) {\n        const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n        offsets.x = offsetRect.x + offsetParent.clientLeft;\n        offsets.y = offsetRect.y + offsetParent.clientTop;\n      } else if (documentElement) {\n        offsets.x = getWindowScrollBarX(documentElement);\n      }\n    }\n    return {\n      x: rect.left + scroll.scrollLeft - offsets.x,\n      y: rect.top + scroll.scrollTop - offsets.y,\n      width: rect.width,\n      height: rect.height\n    };\n  }\n  const platform = {\n    getClippingRect,\n    convertOffsetParentRelativeRectToViewportRelativeRect,\n    isElement,\n    getDimensions,\n    getOffsetParent,\n    getDocumentElement,\n    getScale,\n    async getElementRects(_ref) {\n      let {\n        reference,\n        floating,\n        strategy\n      } = _ref;\n      const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n      const getDimensionsFn = this.getDimensions;\n      return {\n        reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n        floating: {\n          x: 0,\n          y: 0,\n          ...(await getDimensionsFn(floating))\n        }\n      };\n    },\n    getClientRects: element => Array.from(element.getClientRects()),\n    isRTL: element => getComputedStyle$1(element).direction === 'rtl'\n  };\n\n  // https://samthor.au/2021/observing-dom/\n  function observeMove(element, onMove) {\n    let io = null;\n    let timeoutId;\n    const root = getDocumentElement(element);\n    function cleanup() {\n      clearTimeout(timeoutId);\n      io && io.disconnect();\n      io = null;\n    }\n    function refresh(skip, threshold) {\n      if (skip === void 0) {\n        skip = false;\n      }\n      if (threshold === void 0) {\n        threshold = 1;\n      }\n      cleanup();\n      const {\n        left,\n        top,\n        width,\n        height\n      } = element.getBoundingClientRect();\n      if (!skip) {\n        onMove();\n      }\n      if (!width || !height) {\n        return;\n      }\n      const insetTop = floor(top);\n      const insetRight = floor(root.clientWidth - (left + width));\n      const insetBottom = floor(root.clientHeight - (top + height));\n      const insetLeft = floor(left);\n      const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n      let isFirstUpdate = true;\n      io = new IntersectionObserver(entries => {\n        const ratio = entries[0].intersectionRatio;\n        if (ratio !== threshold) {\n          if (!isFirstUpdate) {\n            return refresh();\n          }\n          if (!ratio) {\n            timeoutId = setTimeout(() => {\n              refresh(false, 1e-7);\n            }, 100);\n          } else {\n            refresh(false, ratio);\n          }\n        }\n        isFirstUpdate = false;\n      }, {\n        rootMargin,\n        threshold: max(0, min(1, threshold)) || 1\n      });\n      io.observe(element);\n    }\n    refresh(true);\n    return cleanup;\n  }\n\n  /**\n   * Automatically updates the position of the floating element when necessary.\n   * Should only be called when the floating element is mounted on the DOM or\n   * visible on the screen.\n   * @returns cleanup function that should be invoked when the floating element is\n   * removed from the DOM or hidden from the screen.\n   * @see https://floating-ui.com/docs/autoUpdate\n   */\n  function autoUpdate(reference, floating, update, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    const {\n      ancestorScroll = true,\n      ancestorResize = true,\n      elementResize = true,\n      layoutShift = typeof IntersectionObserver === 'function',\n      animationFrame = false\n    } = options;\n    const referenceEl = unwrapElement(reference);\n    const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.addEventListener('scroll', update, {\n        passive: true\n      });\n      ancestorResize && ancestor.addEventListener('resize', update);\n    });\n    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n    let resizeObserver = null;\n    if (elementResize) {\n      resizeObserver = new ResizeObserver(update);\n      if (referenceEl && !animationFrame) {\n        resizeObserver.observe(referenceEl);\n      }\n      resizeObserver.observe(floating);\n    }\n    let frameId;\n    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n    if (animationFrame) {\n      frameLoop();\n    }\n    function frameLoop() {\n      const nextRefRect = getBoundingClientRect(reference);\n      if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n        update();\n      }\n      prevRefRect = nextRefRect;\n      frameId = requestAnimationFrame(frameLoop);\n    }\n    update();\n    return () => {\n      ancestors.forEach(ancestor => {\n        ancestorScroll && ancestor.removeEventListener('scroll', update);\n        ancestorResize && ancestor.removeEventListener('resize', update);\n      });\n      cleanupIo && cleanupIo();\n      resizeObserver && resizeObserver.disconnect();\n      resizeObserver = null;\n      if (animationFrame) {\n        cancelAnimationFrame(frameId);\n      }\n    };\n  }\n\n  /**\n   * Computes the `x` and `y` coordinates that will place the floating element\n   * next to a reference element when it is given a certain CSS positioning\n   * strategy.\n   */\n  const computePosition = (reference, floating, options) => {\n    // This caches the expensive `getClippingElementAncestors` function so that\n    // multiple lifecycle resets re-use the same result. It only lives for a\n    // single call. If other functions become expensive, we can add them as well.\n    const cache = new Map();\n    const mergedOptions = {\n      platform,\n      ...options\n    };\n    const platformWithCache = {\n      ...mergedOptions.platform,\n      _c: cache\n    };\n    return core.computePosition(reference, floating, {\n      ...mergedOptions,\n      platform: platformWithCache\n    });\n  };\n  Object.defineProperty(exports, 'arrow', {\n    enumerable: true,\n    get: function () {\n      return core.arrow;\n    }\n  });\n  Object.defineProperty(exports, 'autoPlacement', {\n    enumerable: true,\n    get: function () {\n      return core.autoPlacement;\n    }\n  });\n  Object.defineProperty(exports, 'detectOverflow', {\n    enumerable: true,\n    get: function () {\n      return core.detectOverflow;\n    }\n  });\n  Object.defineProperty(exports, 'flip', {\n    enumerable: true,\n    get: function () {\n      return core.flip;\n    }\n  });\n  Object.defineProperty(exports, 'hide', {\n    enumerable: true,\n    get: function () {\n      return core.hide;\n    }\n  });\n  Object.defineProperty(exports, 'inline', {\n    enumerable: true,\n    get: function () {\n      return core.inline;\n    }\n  });\n  Object.defineProperty(exports, 'limitShift', {\n    enumerable: true,\n    get: function () {\n      return core.limitShift;\n    }\n  });\n  Object.defineProperty(exports, 'offset', {\n    enumerable: true,\n    get: function () {\n      return core.offset;\n    }\n  });\n  Object.defineProperty(exports, 'shift', {\n    enumerable: true,\n    get: function () {\n      return core.shift;\n    }\n  });\n  Object.defineProperty(exports, 'size', {\n    enumerable: true,\n    get: function () {\n      return core.size;\n    }\n  });\n  exports.autoUpdate = autoUpdate;\n  exports.computePosition = computePosition;\n  exports.getOverflowAncestors = getOverflowAncestors;\n  exports.platform = platform;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"names":["global","factory","exports","module","require","define","amd","globalThis","self","FloatingUIDOM","FloatingUICore","core","getWindow","node","_node$ownerDocument","ownerDocument","defaultView","window","getComputedStyle$1","element","getComputedStyle","isNode","value","Node","getNodeName","nodeName","toLowerCase","isHTMLElement","HTMLElement","isElement","Element","isShadowRoot","ShadowRoot","isOverflowElement","overflow","overflowX","overflowY","display","test","includes","isTableElement","isContainingBlock","safari","isSafari","css","transform","perspective","backdropFilter","filter","some","willChange","contain","CSS","supports","isLastTraversableNode","min","Math","max","round","floor","createEmptyCoords","v","x","y","getCssDimensions","width","parseFloat","height","hasOffset","offsetWidth","offsetHeight","shouldFallback","$","unwrapElement","contextElement","getScale","domElement","rect","getBoundingClientRect","Number","isFinite","noOffsets","getVisualOffsets","isFixed","floatingOffsetParent","_win$visualViewport","_win$visualViewport2","win","visualViewport","offsetLeft","offsetTop","includeScale","isFixedStrategy","offsetParent","clientRect","scale","visualOffsets","left","top","offsetWin","currentIFrame","frameElement","iframeScale","iframeRect","clientLeft","paddingLeft","clientTop","paddingTop","rectToClientRect","getDocumentElement","document","documentElement","getNodeScroll","scrollLeft","scrollTop","pageXOffset","pageYOffset","convertOffsetParentRelativeRectToViewportRelativeRect","_ref","strategy","isOffsetParentAnElement","scroll","offsets","offsetRect","getWindowScrollBarX","getDocumentRect","html","body","scrollWidth","clientWidth","scrollHeight","clientHeight","direction","getParentNode","result","assignedSlot","parentNode","host","getNearestOverflowAncestor","getOverflowAncestors","list","scrollableAncestor","isBody","concat","getViewportRect","visualViewportBased","getInnerBoundingClientRect","getClientRectFromClippingAncestor","clippingAncestor","hasFixedPositionAncestor","stopNode","position","getClippingElementAncestors","cache","cachedResult","get","el","currentContainingBlockComputedStyle","elementIsFixed","currentNode","computedStyle","currentNodeIsContaining","shouldDropCurrentNode","ancestor","set","getClippingRect","boundary","rootBoundary","elementClippingAncestors","_c","clippingAncestors","firstClippingAncestor","clippingRect","reduce","accRect","right","bottom","getDimensions","getTrueOffsetParent","polyfill","getContainingBlock","getOffsetParent","getRectRelativeToOffsetParent","platform","getElementRects","reference","floating","getOffsetParentFn","getDimensionsFn","getClientRects","Array","from","isRTL","observeMove","onMove","io","timeoutId","root","cleanup","clearTimeout","disconnect","refresh","skip","threshold","insetTop","insetRight","insetBottom","insetLeft","rootMargin","isFirstUpdate","IntersectionObserver","entries","ratio","intersectionRatio","setTimeout","observe","autoUpdate","update","options","ancestorScroll","ancestorResize","elementResize","layoutShift","animationFrame","referenceEl","ancestors","forEach","addEventListener","passive","cleanupIo","resizeObserver","ResizeObserver","frameId","prevRefRect","frameLoop","nextRefRect","requestAnimationFrame","removeEventListener","cancelAnimationFrame","computePosition","Map","mergedOptions","platformWithCache","Object","defineProperty","enumerable","arrow","autoPlacement","detectOverflow","flip","hide","inline","limitShift","offset","shift","size"],"sources":["/Users/stan/Desktop/esg_demo_system/front_end/node_modules/@floating-ui/dom/dist/floating-ui.dom.umd.js"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@floating-ui/core')) :\n  typeof define === 'function' && define.amd ? define(['exports', '@floating-ui/core'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.FloatingUIDOM = {}, global.FloatingUICore));\n})(this, (function (exports, core) { 'use strict';\n\n  function getWindow(node) {\n    var _node$ownerDocument;\n    return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n  }\n\n  function getComputedStyle$1(element) {\n    return getWindow(element).getComputedStyle(element);\n  }\n\n  function isNode(value) {\n    return value instanceof getWindow(value).Node;\n  }\n  function getNodeName(node) {\n    if (isNode(node)) {\n      return (node.nodeName || '').toLowerCase();\n    }\n    // Mocked nodes in testing environments may not be instances of Node. By\n    // returning `#document` an infinite loop won't occur.\n    // https://github.com/floating-ui/floating-ui/issues/2317\n    return '#document';\n  }\n\n  function isHTMLElement(value) {\n    return value instanceof getWindow(value).HTMLElement;\n  }\n  function isElement(value) {\n    return value instanceof getWindow(value).Element;\n  }\n  function isShadowRoot(node) {\n    // Browsers without `ShadowRoot` support.\n    if (typeof ShadowRoot === 'undefined') {\n      return false;\n    }\n    return node instanceof getWindow(node).ShadowRoot || node instanceof ShadowRoot;\n  }\n  function isOverflowElement(element) {\n    const {\n      overflow,\n      overflowX,\n      overflowY,\n      display\n    } = getComputedStyle$1(element);\n    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n  }\n  function isTableElement(element) {\n    return ['table', 'td', 'th'].includes(getNodeName(element));\n  }\n  function isContainingBlock(element) {\n    const safari = isSafari();\n    const css = getComputedStyle$1(element);\n\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    return css.transform !== 'none' || css.perspective !== 'none' || !safari && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !safari && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n  }\n  function isSafari() {\n    if (typeof CSS === 'undefined' || !CSS.supports) return false;\n    return CSS.supports('-webkit-backdrop-filter', 'none');\n  }\n  function isLastTraversableNode(node) {\n    return ['html', 'body', '#document'].includes(getNodeName(node));\n  }\n\n  const min = Math.min;\n  const max = Math.max;\n  const round = Math.round;\n  const floor = Math.floor;\n  const createEmptyCoords = v => ({\n    x: v,\n    y: v\n  });\n\n  function getCssDimensions(element) {\n    const css = getComputedStyle$1(element);\n    // In testing environments, the `width` and `height` properties are empty\n    // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n    let width = parseFloat(css.width) || 0;\n    let height = parseFloat(css.height) || 0;\n    const hasOffset = isHTMLElement(element);\n    const offsetWidth = hasOffset ? element.offsetWidth : width;\n    const offsetHeight = hasOffset ? element.offsetHeight : height;\n    const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n    if (shouldFallback) {\n      width = offsetWidth;\n      height = offsetHeight;\n    }\n    return {\n      width,\n      height,\n      $: shouldFallback\n    };\n  }\n\n  function unwrapElement(element) {\n    return !isElement(element) ? element.contextElement : element;\n  }\n\n  function getScale(element) {\n    const domElement = unwrapElement(element);\n    if (!isHTMLElement(domElement)) {\n      return createEmptyCoords(1);\n    }\n    const rect = domElement.getBoundingClientRect();\n    const {\n      width,\n      height,\n      $\n    } = getCssDimensions(domElement);\n    let x = ($ ? round(rect.width) : rect.width) / width;\n    let y = ($ ? round(rect.height) : rect.height) / height;\n\n    // 0, NaN, or Infinity should always fallback to 1.\n\n    if (!x || !Number.isFinite(x)) {\n      x = 1;\n    }\n    if (!y || !Number.isFinite(y)) {\n      y = 1;\n    }\n    return {\n      x,\n      y\n    };\n  }\n\n  const noOffsets = /*#__PURE__*/createEmptyCoords(0);\n  function getVisualOffsets(element, isFixed, floatingOffsetParent) {\n    var _win$visualViewport, _win$visualViewport2;\n    if (isFixed === void 0) {\n      isFixed = true;\n    }\n    if (!isSafari()) {\n      return noOffsets;\n    }\n    const win = element ? getWindow(element) : window;\n    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== win) {\n      return noOffsets;\n    }\n    return {\n      x: ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0,\n      y: ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0\n    };\n  }\n\n  function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n    if (includeScale === void 0) {\n      includeScale = false;\n    }\n    if (isFixedStrategy === void 0) {\n      isFixedStrategy = false;\n    }\n    const clientRect = element.getBoundingClientRect();\n    const domElement = unwrapElement(element);\n    let scale = createEmptyCoords(1);\n    if (includeScale) {\n      if (offsetParent) {\n        if (isElement(offsetParent)) {\n          scale = getScale(offsetParent);\n        }\n      } else {\n        scale = getScale(element);\n      }\n    }\n    const visualOffsets = getVisualOffsets(domElement, isFixedStrategy, offsetParent);\n    let x = (clientRect.left + visualOffsets.x) / scale.x;\n    let y = (clientRect.top + visualOffsets.y) / scale.y;\n    let width = clientRect.width / scale.x;\n    let height = clientRect.height / scale.y;\n    if (domElement) {\n      const win = getWindow(domElement);\n      const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n      let currentIFrame = win.frameElement;\n      while (currentIFrame && offsetParent && offsetWin !== win) {\n        const iframeScale = getScale(currentIFrame);\n        const iframeRect = currentIFrame.getBoundingClientRect();\n        const css = getComputedStyle(currentIFrame);\n        const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n        const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n        x *= iframeScale.x;\n        y *= iframeScale.y;\n        width *= iframeScale.x;\n        height *= iframeScale.y;\n        x += left;\n        y += top;\n        currentIFrame = getWindow(currentIFrame).frameElement;\n      }\n    }\n    return core.rectToClientRect({\n      width,\n      height,\n      x,\n      y\n    });\n  }\n\n  function getDocumentElement(node) {\n    return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n  }\n\n  function getNodeScroll(element) {\n    if (isElement(element)) {\n      return {\n        scrollLeft: element.scrollLeft,\n        scrollTop: element.scrollTop\n      };\n    }\n    return {\n      scrollLeft: element.pageXOffset,\n      scrollTop: element.pageYOffset\n    };\n  }\n\n  function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n    let {\n      rect,\n      offsetParent,\n      strategy\n    } = _ref;\n    const isOffsetParentAnElement = isHTMLElement(offsetParent);\n    const documentElement = getDocumentElement(offsetParent);\n    if (offsetParent === documentElement) {\n      return rect;\n    }\n    let scroll = {\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    let scale = createEmptyCoords(1);\n    const offsets = createEmptyCoords(0);\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n      if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n        scroll = getNodeScroll(offsetParent);\n      }\n      if (isHTMLElement(offsetParent)) {\n        const offsetRect = getBoundingClientRect(offsetParent);\n        scale = getScale(offsetParent);\n        offsets.x = offsetRect.x + offsetParent.clientLeft;\n        offsets.y = offsetRect.y + offsetParent.clientTop;\n      }\n    }\n    return {\n      width: rect.width * scale.x,\n      height: rect.height * scale.y,\n      x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n      y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n    };\n  }\n\n  function getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n  }\n\n  // Gets the entire size of the scrollable document area, even extending outside\n  // of the `<html>` and `<body>` rect bounds if horizontally scrollable.\n  function getDocumentRect(element) {\n    const html = getDocumentElement(element);\n    const scroll = getNodeScroll(element);\n    const body = element.ownerDocument.body;\n    const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n    const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n    let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n    const y = -scroll.scrollTop;\n    if (getComputedStyle$1(body).direction === 'rtl') {\n      x += max(html.clientWidth, body.clientWidth) - width;\n    }\n    return {\n      width,\n      height,\n      x,\n      y\n    };\n  }\n\n  function getParentNode(node) {\n    if (getNodeName(node) === 'html') {\n      return node;\n    }\n    const result =\n    // Step into the shadow DOM of the parent of a slotted node.\n    node.assignedSlot ||\n    // DOM Element detected.\n    node.parentNode ||\n    // ShadowRoot detected.\n    isShadowRoot(node) && node.host ||\n    // Fallback.\n    getDocumentElement(node);\n    return isShadowRoot(result) ? result.host : result;\n  }\n\n  function getNearestOverflowAncestor(node) {\n    const parentNode = getParentNode(node);\n    if (isLastTraversableNode(parentNode)) {\n      return node.ownerDocument ? node.ownerDocument.body : node.body;\n    }\n    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n      return parentNode;\n    }\n    return getNearestOverflowAncestor(parentNode);\n  }\n\n  function getOverflowAncestors(node, list) {\n    var _node$ownerDocument;\n    if (list === void 0) {\n      list = [];\n    }\n    const scrollableAncestor = getNearestOverflowAncestor(node);\n    const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n    const win = getWindow(scrollableAncestor);\n    if (isBody) {\n      return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);\n    }\n    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));\n  }\n\n  function getViewportRect(element, strategy) {\n    const win = getWindow(element);\n    const html = getDocumentElement(element);\n    const visualViewport = win.visualViewport;\n    let width = html.clientWidth;\n    let height = html.clientHeight;\n    let x = 0;\n    let y = 0;\n    if (visualViewport) {\n      width = visualViewport.width;\n      height = visualViewport.height;\n      const visualViewportBased = isSafari();\n      if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n        x = visualViewport.offsetLeft;\n        y = visualViewport.offsetTop;\n      }\n    }\n    return {\n      width,\n      height,\n      x,\n      y\n    };\n  }\n\n  // Returns the inner client rect, subtracting scrollbars if present.\n  function getInnerBoundingClientRect(element, strategy) {\n    const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n    const top = clientRect.top + element.clientTop;\n    const left = clientRect.left + element.clientLeft;\n    const scale = isHTMLElement(element) ? getScale(element) : createEmptyCoords(1);\n    const width = element.clientWidth * scale.x;\n    const height = element.clientHeight * scale.y;\n    const x = left * scale.x;\n    const y = top * scale.y;\n    return {\n      width,\n      height,\n      x,\n      y\n    };\n  }\n  function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n    let rect;\n    if (clippingAncestor === 'viewport') {\n      rect = getViewportRect(element, strategy);\n    } else if (clippingAncestor === 'document') {\n      rect = getDocumentRect(getDocumentElement(element));\n    } else if (isElement(clippingAncestor)) {\n      rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n    } else {\n      const visualOffsets = getVisualOffsets(element);\n      rect = {\n        ...clippingAncestor,\n        x: clippingAncestor.x - visualOffsets.x,\n        y: clippingAncestor.y - visualOffsets.y\n      };\n    }\n    return core.rectToClientRect(rect);\n  }\n  function hasFixedPositionAncestor(element, stopNode) {\n    const parentNode = getParentNode(element);\n    if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n      return false;\n    }\n    return getComputedStyle$1(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n  }\n\n  // A \"clipping ancestor\" is an `overflow` element with the characteristic of\n  // clipping (or hiding) child elements. This returns all clipping ancestors\n  // of the given element up the tree.\n  function getClippingElementAncestors(element, cache) {\n    const cachedResult = cache.get(element);\n    if (cachedResult) {\n      return cachedResult;\n    }\n    let result = getOverflowAncestors(element).filter(el => isElement(el) && getNodeName(el) !== 'body');\n    let currentContainingBlockComputedStyle = null;\n    const elementIsFixed = getComputedStyle$1(element).position === 'fixed';\n    let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n      const computedStyle = getComputedStyle$1(currentNode);\n      const currentNodeIsContaining = isContainingBlock(currentNode);\n      if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n        currentContainingBlockComputedStyle = null;\n      }\n      const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n      if (shouldDropCurrentNode) {\n        // Drop non-containing blocks.\n        result = result.filter(ancestor => ancestor !== currentNode);\n      } else {\n        // Record last containing block for next iteration.\n        currentContainingBlockComputedStyle = computedStyle;\n      }\n      currentNode = getParentNode(currentNode);\n    }\n    cache.set(element, result);\n    return result;\n  }\n\n  // Gets the maximum area that the element is visible in due to any number of\n  // clipping ancestors.\n  function getClippingRect(_ref) {\n    let {\n      element,\n      boundary,\n      rootBoundary,\n      strategy\n    } = _ref;\n    const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n    const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n    const firstClippingAncestor = clippingAncestors[0];\n    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n      const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n      accRect.top = max(rect.top, accRect.top);\n      accRect.right = min(rect.right, accRect.right);\n      accRect.bottom = min(rect.bottom, accRect.bottom);\n      accRect.left = max(rect.left, accRect.left);\n      return accRect;\n    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n    return {\n      width: clippingRect.right - clippingRect.left,\n      height: clippingRect.bottom - clippingRect.top,\n      x: clippingRect.left,\n      y: clippingRect.top\n    };\n  }\n\n  function getDimensions(element) {\n    return getCssDimensions(element);\n  }\n\n  function getTrueOffsetParent(element, polyfill) {\n    if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {\n      return null;\n    }\n    if (polyfill) {\n      return polyfill(element);\n    }\n    return element.offsetParent;\n  }\n  function getContainingBlock(element) {\n    let currentNode = getParentNode(element);\n    while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n      if (isContainingBlock(currentNode)) {\n        return currentNode;\n      } else {\n        currentNode = getParentNode(currentNode);\n      }\n    }\n    return null;\n  }\n\n  // Gets the closest ancestor positioned element. Handles some edge cases,\n  // such as table ancestors and cross browser bugs.\n  function getOffsetParent(element, polyfill) {\n    const window = getWindow(element);\n    if (!isHTMLElement(element)) {\n      return window;\n    }\n    let offsetParent = getTrueOffsetParent(element, polyfill);\n    while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {\n      offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n    }\n    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n      return window;\n    }\n    return offsetParent || getContainingBlock(element) || window;\n  }\n\n  function getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n    const isOffsetParentAnElement = isHTMLElement(offsetParent);\n    const documentElement = getDocumentElement(offsetParent);\n    const isFixed = strategy === 'fixed';\n    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n    let scroll = {\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    const offsets = createEmptyCoords(0);\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n      if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n        scroll = getNodeScroll(offsetParent);\n      }\n      if (isHTMLElement(offsetParent)) {\n        const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n        offsets.x = offsetRect.x + offsetParent.clientLeft;\n        offsets.y = offsetRect.y + offsetParent.clientTop;\n      } else if (documentElement) {\n        offsets.x = getWindowScrollBarX(documentElement);\n      }\n    }\n    return {\n      x: rect.left + scroll.scrollLeft - offsets.x,\n      y: rect.top + scroll.scrollTop - offsets.y,\n      width: rect.width,\n      height: rect.height\n    };\n  }\n\n  const platform = {\n    getClippingRect,\n    convertOffsetParentRelativeRectToViewportRelativeRect,\n    isElement,\n    getDimensions,\n    getOffsetParent,\n    getDocumentElement,\n    getScale,\n    async getElementRects(_ref) {\n      let {\n        reference,\n        floating,\n        strategy\n      } = _ref;\n      const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n      const getDimensionsFn = this.getDimensions;\n      return {\n        reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n        floating: {\n          x: 0,\n          y: 0,\n          ...(await getDimensionsFn(floating))\n        }\n      };\n    },\n    getClientRects: element => Array.from(element.getClientRects()),\n    isRTL: element => getComputedStyle$1(element).direction === 'rtl'\n  };\n\n  // https://samthor.au/2021/observing-dom/\n  function observeMove(element, onMove) {\n    let io = null;\n    let timeoutId;\n    const root = getDocumentElement(element);\n    function cleanup() {\n      clearTimeout(timeoutId);\n      io && io.disconnect();\n      io = null;\n    }\n    function refresh(skip, threshold) {\n      if (skip === void 0) {\n        skip = false;\n      }\n      if (threshold === void 0) {\n        threshold = 1;\n      }\n      cleanup();\n      const {\n        left,\n        top,\n        width,\n        height\n      } = element.getBoundingClientRect();\n      if (!skip) {\n        onMove();\n      }\n      if (!width || !height) {\n        return;\n      }\n      const insetTop = floor(top);\n      const insetRight = floor(root.clientWidth - (left + width));\n      const insetBottom = floor(root.clientHeight - (top + height));\n      const insetLeft = floor(left);\n      const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n      let isFirstUpdate = true;\n      io = new IntersectionObserver(entries => {\n        const ratio = entries[0].intersectionRatio;\n        if (ratio !== threshold) {\n          if (!isFirstUpdate) {\n            return refresh();\n          }\n          if (!ratio) {\n            timeoutId = setTimeout(() => {\n              refresh(false, 1e-7);\n            }, 100);\n          } else {\n            refresh(false, ratio);\n          }\n        }\n        isFirstUpdate = false;\n      }, {\n        rootMargin,\n        threshold: max(0, min(1, threshold)) || 1\n      });\n      io.observe(element);\n    }\n    refresh(true);\n    return cleanup;\n  }\n\n  /**\n   * Automatically updates the position of the floating element when necessary.\n   * Should only be called when the floating element is mounted on the DOM or\n   * visible on the screen.\n   * @returns cleanup function that should be invoked when the floating element is\n   * removed from the DOM or hidden from the screen.\n   * @see https://floating-ui.com/docs/autoUpdate\n   */\n  function autoUpdate(reference, floating, update, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    const {\n      ancestorScroll = true,\n      ancestorResize = true,\n      elementResize = true,\n      layoutShift = typeof IntersectionObserver === 'function',\n      animationFrame = false\n    } = options;\n    const referenceEl = unwrapElement(reference);\n    const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.addEventListener('scroll', update, {\n        passive: true\n      });\n      ancestorResize && ancestor.addEventListener('resize', update);\n    });\n    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n    let resizeObserver = null;\n    if (elementResize) {\n      resizeObserver = new ResizeObserver(update);\n      if (referenceEl && !animationFrame) {\n        resizeObserver.observe(referenceEl);\n      }\n      resizeObserver.observe(floating);\n    }\n    let frameId;\n    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n    if (animationFrame) {\n      frameLoop();\n    }\n    function frameLoop() {\n      const nextRefRect = getBoundingClientRect(reference);\n      if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n        update();\n      }\n      prevRefRect = nextRefRect;\n      frameId = requestAnimationFrame(frameLoop);\n    }\n    update();\n    return () => {\n      ancestors.forEach(ancestor => {\n        ancestorScroll && ancestor.removeEventListener('scroll', update);\n        ancestorResize && ancestor.removeEventListener('resize', update);\n      });\n      cleanupIo && cleanupIo();\n      resizeObserver && resizeObserver.disconnect();\n      resizeObserver = null;\n      if (animationFrame) {\n        cancelAnimationFrame(frameId);\n      }\n    };\n  }\n\n  /**\n   * Computes the `x` and `y` coordinates that will place the floating element\n   * next to a reference element when it is given a certain CSS positioning\n   * strategy.\n   */\n  const computePosition = (reference, floating, options) => {\n    // This caches the expensive `getClippingElementAncestors` function so that\n    // multiple lifecycle resets re-use the same result. It only lives for a\n    // single call. If other functions become expensive, we can add them as well.\n    const cache = new Map();\n    const mergedOptions = {\n      platform,\n      ...options\n    };\n    const platformWithCache = {\n      ...mergedOptions.platform,\n      _c: cache\n    };\n    return core.computePosition(reference, floating, {\n      ...mergedOptions,\n      platform: platformWithCache\n    });\n  };\n\n  Object.defineProperty(exports, 'arrow', {\n    enumerable: true,\n    get: function () { return core.arrow; }\n  });\n  Object.defineProperty(exports, 'autoPlacement', {\n    enumerable: true,\n    get: function () { return core.autoPlacement; }\n  });\n  Object.defineProperty(exports, 'detectOverflow', {\n    enumerable: true,\n    get: function () { return core.detectOverflow; }\n  });\n  Object.defineProperty(exports, 'flip', {\n    enumerable: true,\n    get: function () { return core.flip; }\n  });\n  Object.defineProperty(exports, 'hide', {\n    enumerable: true,\n    get: function () { return core.hide; }\n  });\n  Object.defineProperty(exports, 'inline', {\n    enumerable: true,\n    get: function () { return core.inline; }\n  });\n  Object.defineProperty(exports, 'limitShift', {\n    enumerable: true,\n    get: function () { return core.limitShift; }\n  });\n  Object.defineProperty(exports, 'offset', {\n    enumerable: true,\n    get: function () { return core.offset; }\n  });\n  Object.defineProperty(exports, 'shift', {\n    enumerable: true,\n    get: function () { return core.shift; }\n  });\n  Object.defineProperty(exports, 'size', {\n    enumerable: true,\n    get: function () { return core.size; }\n  });\n  exports.autoUpdate = autoUpdate;\n  exports.computePosition = computePosition;\n  exports.getOverflowAncestors = getOverflowAncestors;\n  exports.platform = platform;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}