{"ast":null,"code":"// import React, { useState, useEffect, useRef } from 'react';\n// import * as d3 from 'd3';\n// import { useParams } from 'react-router-dom';\n// import '../styles/TreeDiagram.css';\n\n// function TreeVisualisation() {\n//   const { filename: filenameFromParams } = useParams();\n//   const ref = useRef(null);\n//   const [loading, setLoading] = useState(true);\n\n//   useEffect(() => {\n//       console.log(\"Filename from params: \", filenameFromParams);\n//       drawTree(filenameFromParams);\n//   }, [filenameFromParams]);\n\n//   const drawTree = (filename) => {\n//       let i = 0;\n//       let duration = 800;\n//       let root;\n\n//   const svgContainer = d3.select(ref.current)\n\n//   svgContainer.selectAll(\"*\").remove();\n\n//   const zoom = d3.zoom()\n//       .scaleExtent([0.5, 10])\n//       .on(\"zoom\", function (event){\n//           svg.attr(\"transform\", event.transform)\n//       });\n\n//   const svg = svgContainer.append(\"svg\")\n//       .attr(\"width\", \"100%\")\n//       .attr(\"height\", \"100%\")\n//       .attr(\"viewBox\", \"-100 -20 2000 1000\")\n//       .attr(\"preserveAspectRatio\", \"xMidYMid meet\")\n//       .call(zoom)\n//       .append(\"g\");\n\n//       const treemap = d3.tree().size([900, 800])\n//       .separation(function(a, b) {\n//           return (a.parent === b.parent ? 1 : 2) / a.depth;\n//       });\n\n//       function centerTree() {\n//           const nodesExtent = d3.extent(svg.selectAll('.node').nodes(), function(d) {\n//               const bbox = d.getBBox();\n//               const matrix = d.getCTM();\n//               return matrix ? [matrix.e + bbox.x, matrix.e + bbox.x + bbox.width]: [0,0];\n//           });\n\n//           const xOffset = (nodesExtent[0] + nodesExtent[1]) / -2;\n//           const scale = 0.8; // You can adjust the scale as needed\n//           svgContainer.transition()\n//               .duration(duration)\n//               .call(zoom.transform, d3.zoomIdentity.translate(xOffset, 0).scale(scale));\n//       }\n\n//   d3.json(`http://localhost:3000/processed_data/${filename}`)\n//     .then((treeData) => { \n//       console.log(\"Received tree data: \", treeData);\n//       root = d3.hierarchy(treeData, function(d) { return d.children; });\n//       root.x0 = window.innerHeight / 2;\n//       root.y0 = window.innerWidth / 10;\n//       root.children.forEach(collapse);\n//       update(root);\n//       centerTree();\n//       setLoading(false);\n//     })\n//     .catch(error => {\n//       console.error(\"Error occurred while fetching and processing data: \", error);\n//       setLoading(false);\n//     });\n\n//     const collapse = (d) => {\n//       if(d.children) {\n//         d._children = d.children;\n//         d._children.forEach(collapse);\n//         d.children = null;\n//       }\n//     }\n\n//     const update = (source) => {\n//       const treeData = treemap(root);\n//       const nodes = treeData.descendants();\n//       const links = treeData.descendants().slice(1);\n//       nodes.forEach(function(d){ d.y = d.depth * 1250});\n//       const node = svg.selectAll('g.node')\n//           .data(nodes, function(d) {return d.id || (d.id = ++i); });\n\n//       const nodeEnter = node.enter().append('g')\n//           .attr('class', 'node')\n//           .attr(\"transform\", function(d) {\n//             return \"translate(\" + source.y0 + \",\" + source.x0 + \")\";\n//         })\n//         .on('click', (event, d) => click(d));\n\n//       nodeEnter.append('circle')\n//           .attr('class', 'node')\n//           .attr('r', 1e-4)\n//           .style(\"fill\", function(d) {\n//               return d._children ? \"lightsteelblue\" : \"#fff\";\n//           });\n\n//       nodeEnter.append('text')\n//       .attr(\"dy\", \" -1em\") // Shifts the text vertically so it's centered on the node\n//       .attr(\"x\", 0) // Centers the text horizontally on the node\n//       .style(\"text-anchor\", \"middle\") // Ensures the text is centered at its position\n//       .text(function(d) { return d.data.name; });\n//       const nodeUpdate = nodeEnter.merge(node);\n\n//       nodeUpdate.transition()\n//         .duration(duration)\n//         .attr(\"transform\", function(d) { \n//             return \"translate(\" + d.y + \",\" + d.x + \")\";\n//          });\n\n//       nodeUpdate.select('circle.node')\n//         .attr('r', 15)\n//         .style(\"fill\", function(d) {\n//             if (d._children) {\n//               return \"lightsteelblue\";\n//             } else if (d.children) {\n//               return \"green\";\n//             } else {\n//               return \"#fff\";\n//             }\n//         })\n//         .attr('cursor', 'pointer');\n\n//       const nodeExit = node.exit().transition()\n//           .duration(duration)\n//           .attr(\"transform\", function(d) {\n//               return \"translate(\" + source.y + \",\" + source.x + \")\";\n//           })\n//           .remove();\n\n//       nodeExit.select('circle')\n//         .attr('r', 1e-5);\n\n//       nodeExit.select('text')\n//         .style('fill-opacity', 1e-5);\n\n//       const link = svg.selectAll('path.link')\n//           .data(links, function(d) { return d.id; });\n\n//       const linkEnter = link.enter().insert('path', \"g\")\n//           .attr(\"class\", \"link\")\n//           .attr('d', function(d){\n//             var o = {x: source.x0, y: source.y0}\n//             return diagonal(o, o)\n//           });\n\n//       const linkUpdate = linkEnter.merge(link);\n\n//       linkUpdate.transition()\n//           .duration(duration)\n//           .attr('d', function(d){ return diagonal(d, d.parent) });\n\n//       const linkExit = link.exit().transition()\n//           .duration(duration)\n//           .attr('d', function(d) {\n//             var o = {x: source.x, y: source.y}\n//             return diagonal(o, o)\n//           })\n//           .remove();\n\n//       nodes.forEach(function(d){\n//         d.x0 = d.x;\n//         d.y0 = d.y;\n//       });\n\n//       function click(d) {\n//           let nodeToFocus;\n\n//           // If the clicked node is the root\n//           if (d.depth === 0) {\n//             if (d.children) { // If the root node has children\n//               collapseAll(d); // Collapse all children\n//             } else if (d._children) { // If the root node has collapsed children\n//               d.children = d._children; // Expand the root node\n//               d._children = null;\n//             }\n//             nodeToFocus = d; // Set the root node as the node to focus\n//           } else {\n//             if (d.children) {\n//               d._children = d.children;\n//               d.children = null;\n//               nodeToFocus = d.parent;\n//             } else {\n//               d.children = d._children;\n//               d._children = null;\n//               nodeToFocus = d;\n//             }\n//           }\n\n//           update(nodeToFocus); // Update with the node to focus\n//           centerNode(nodeToFocus); // Center the node to focus\n//         }\n\n//         // This function will recursively collapse all children of a node\n//         function collapseAll(node) {\n//           if (node.children) {\n//             node.children.forEach(collapseAll); // Call this function for each child\n//             node._children = node.children; \n//             node.children = null; \n//           }\n//         }\n\n//       function centerNode(source){\n//               let scale = 0.8;\n//               let x = -source.y * scale + 300; // 750 is half of 1500 (the size defined for the tree layout)\n//               let y = -source.x * scale + 300;\n//               svgContainer.transition()\n//                   .duration(duration)\n//                   .ease(d3.easeCubic)\n//                   .call(zoom.transform, d3.zoomIdentity.translate(x, y).scale(scale));\n//       }\n\n//       function diagonal(s, d) {\n\n//         const path = `M ${s.y} ${s.x}\n//               C ${(s.y + d.y) / 2} ${s.x},\n//                 ${(s.y + d.y) / 2} ${d.x},\n//                 ${d.y} ${d.x}`\n\n//         return path\n//       }\n//     }\n//   }\n\n//   return (\n//     <div className=\"visualisation\">\n//       {loading ?\n//       <div>Loading...</div> : null}\n//       <div className={`svg-container ${loading ? 'hidden' : ''}`} ref={ref}></div>\n//     </div>\n//   );\n// }\n\n// export default TreeVisualisation;","map":{"version":3,"names":[],"sources":["/Users/stan/Desktop/esg_demo_system/front_end/src/pages/TreeVisualisation.js"],"sourcesContent":["// import React, { useState, useEffect, useRef } from 'react';\n// import * as d3 from 'd3';\n// import { useParams } from 'react-router-dom';\n// import '../styles/TreeDiagram.css';\n\n// function TreeVisualisation() {\n//   const { filename: filenameFromParams } = useParams();\n//   const ref = useRef(null);\n//   const [loading, setLoading] = useState(true);\n\n//   useEffect(() => {\n//       console.log(\"Filename from params: \", filenameFromParams);\n//       drawTree(filenameFromParams);\n//   }, [filenameFromParams]);\n\n//   const drawTree = (filename) => {\n//       let i = 0;\n//       let duration = 800;\n//       let root;\n\n//   const svgContainer = d3.select(ref.current)\n\n//   svgContainer.selectAll(\"*\").remove();\n  \n//   const zoom = d3.zoom()\n//       .scaleExtent([0.5, 10])\n//       .on(\"zoom\", function (event){\n//           svg.attr(\"transform\", event.transform)\n//       });\n\n//   const svg = svgContainer.append(\"svg\")\n//       .attr(\"width\", \"100%\")\n//       .attr(\"height\", \"100%\")\n//       .attr(\"viewBox\", \"-100 -20 2000 1000\")\n//       .attr(\"preserveAspectRatio\", \"xMidYMid meet\")\n//       .call(zoom)\n//       .append(\"g\");\n\n//       const treemap = d3.tree().size([900, 800])\n//       .separation(function(a, b) {\n//           return (a.parent === b.parent ? 1 : 2) / a.depth;\n//       });\n\n//       function centerTree() {\n//           const nodesExtent = d3.extent(svg.selectAll('.node').nodes(), function(d) {\n//               const bbox = d.getBBox();\n//               const matrix = d.getCTM();\n//               return matrix ? [matrix.e + bbox.x, matrix.e + bbox.x + bbox.width]: [0,0];\n//           });\n      \n//           const xOffset = (nodesExtent[0] + nodesExtent[1]) / -2;\n//           const scale = 0.8; // You can adjust the scale as needed\n//           svgContainer.transition()\n//               .duration(duration)\n//               .call(zoom.transform, d3.zoomIdentity.translate(xOffset, 0).scale(scale));\n//       }\n\n//   d3.json(`http://localhost:3000/processed_data/${filename}`)\n//     .then((treeData) => { \n//       console.log(\"Received tree data: \", treeData);\n//       root = d3.hierarchy(treeData, function(d) { return d.children; });\n//       root.x0 = window.innerHeight / 2;\n//       root.y0 = window.innerWidth / 10;\n//       root.children.forEach(collapse);\n//       update(root);\n//       centerTree();\n//       setLoading(false);\n//     })\n//     .catch(error => {\n//       console.error(\"Error occurred while fetching and processing data: \", error);\n//       setLoading(false);\n//     });\n\n//     const collapse = (d) => {\n//       if(d.children) {\n//         d._children = d.children;\n//         d._children.forEach(collapse);\n//         d.children = null;\n//       }\n//     }\n\n//     const update = (source) => {\n//       const treeData = treemap(root);\n//       const nodes = treeData.descendants();\n//       const links = treeData.descendants().slice(1);\n//       nodes.forEach(function(d){ d.y = d.depth * 1250});\n//       const node = svg.selectAll('g.node')\n//           .data(nodes, function(d) {return d.id || (d.id = ++i); });\n\n//       const nodeEnter = node.enter().append('g')\n//           .attr('class', 'node')\n//           .attr(\"transform\", function(d) {\n//             return \"translate(\" + source.y0 + \",\" + source.x0 + \")\";\n//         })\n//         .on('click', (event, d) => click(d));\n\n//       nodeEnter.append('circle')\n//           .attr('class', 'node')\n//           .attr('r', 1e-4)\n//           .style(\"fill\", function(d) {\n//               return d._children ? \"lightsteelblue\" : \"#fff\";\n//           });\n\n//       nodeEnter.append('text')\n//       .attr(\"dy\", \" -1em\") // Shifts the text vertically so it's centered on the node\n//       .attr(\"x\", 0) // Centers the text horizontally on the node\n//       .style(\"text-anchor\", \"middle\") // Ensures the text is centered at its position\n//       .text(function(d) { return d.data.name; });\n//       const nodeUpdate = nodeEnter.merge(node);\n\n//       nodeUpdate.transition()\n//         .duration(duration)\n//         .attr(\"transform\", function(d) { \n//             return \"translate(\" + d.y + \",\" + d.x + \")\";\n//          });\n\n//       nodeUpdate.select('circle.node')\n//         .attr('r', 15)\n//         .style(\"fill\", function(d) {\n//             if (d._children) {\n//               return \"lightsteelblue\";\n//             } else if (d.children) {\n//               return \"green\";\n//             } else {\n//               return \"#fff\";\n//             }\n//         })\n//         .attr('cursor', 'pointer');\n\n//       const nodeExit = node.exit().transition()\n//           .duration(duration)\n//           .attr(\"transform\", function(d) {\n//               return \"translate(\" + source.y + \",\" + source.x + \")\";\n//           })\n//           .remove();\n\n//       nodeExit.select('circle')\n//         .attr('r', 1e-5);\n\n//       nodeExit.select('text')\n//         .style('fill-opacity', 1e-5);\n\n//       const link = svg.selectAll('path.link')\n//           .data(links, function(d) { return d.id; });\n\n//       const linkEnter = link.enter().insert('path', \"g\")\n//           .attr(\"class\", \"link\")\n//           .attr('d', function(d){\n//             var o = {x: source.x0, y: source.y0}\n//             return diagonal(o, o)\n//           });\n\n//       const linkUpdate = linkEnter.merge(link);\n\n//       linkUpdate.transition()\n//           .duration(duration)\n//           .attr('d', function(d){ return diagonal(d, d.parent) });\n\n//       const linkExit = link.exit().transition()\n//           .duration(duration)\n//           .attr('d', function(d) {\n//             var o = {x: source.x, y: source.y}\n//             return diagonal(o, o)\n//           })\n//           .remove();\n\n//       nodes.forEach(function(d){\n//         d.x0 = d.x;\n//         d.y0 = d.y;\n//       });\n\n//       function click(d) {\n//           let nodeToFocus;\n          \n//           // If the clicked node is the root\n//           if (d.depth === 0) {\n//             if (d.children) { // If the root node has children\n//               collapseAll(d); // Collapse all children\n//             } else if (d._children) { // If the root node has collapsed children\n//               d.children = d._children; // Expand the root node\n//               d._children = null;\n//             }\n//             nodeToFocus = d; // Set the root node as the node to focus\n//           } else {\n//             if (d.children) {\n//               d._children = d.children;\n//               d.children = null;\n//               nodeToFocus = d.parent;\n//             } else {\n//               d.children = d._children;\n//               d._children = null;\n//               nodeToFocus = d;\n//             }\n//           }\n        \n//           update(nodeToFocus); // Update with the node to focus\n//           centerNode(nodeToFocus); // Center the node to focus\n//         }\n        \n//         // This function will recursively collapse all children of a node\n//         function collapseAll(node) {\n//           if (node.children) {\n//             node.children.forEach(collapseAll); // Call this function for each child\n//             node._children = node.children; \n//             node.children = null; \n//           }\n//         }\n        \n//       function centerNode(source){\n//               let scale = 0.8;\n//               let x = -source.y * scale + 300; // 750 is half of 1500 (the size defined for the tree layout)\n//               let y = -source.x * scale + 300;\n//               svgContainer.transition()\n//                   .duration(duration)\n//                   .ease(d3.easeCubic)\n//                   .call(zoom.transform, d3.zoomIdentity.translate(x, y).scale(scale));\n//       }\n      \n//       function diagonal(s, d) {\n\n//         const path = `M ${s.y} ${s.x}\n//               C ${(s.y + d.y) / 2} ${s.x},\n//                 ${(s.y + d.y) / 2} ${d.x},\n//                 ${d.y} ${d.x}`\n\n//         return path\n//       }\n//     }\n//   }\n\n//   return (\n//     <div className=\"visualisation\">\n//       {loading ?\n//       <div>Loading...</div> : null}\n//       <div className={`svg-container ${loading ? 'hidden' : ''}`} ref={ref}></div>\n//     </div>\n//   );\n// }\n\n// export default TreeVisualisation;"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA"},"metadata":{},"sourceType":"module"}